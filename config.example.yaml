environment: mytest
server:
  port: 8080
  max_connection_duration: 2h
  base_url: "http://localhost:8080"  # Base URL for approval callbacks

# Storage configuration (optional - defaults to file)
storage:
  type: file  # Options: file, kubernetes
  path: config.yaml  # For file backend
  versions: 5  # Number of versions to keep

  # For Kubernetes backend (when running in K8s):
  # type: kubernetes
  # namespace: default
  # resource_type: configmap  # or secret
  # resource_name: port-authorizing-config

auth:
  # JWT Secret can be plain string (legacy) or from ConfigMap/Secret
  jwt_secret: "your-secret-key-change-this-in-production"
  
  # To read from Kubernetes Secret:
  # jwt_secret:
  #   type: secret
  #   ref: port-authorizing-secrets
  #   ref_name: jwt-secret
  #   value: "fallback-value-if-secret-not-found"
  
  # To read from ConfigMap:
  # jwt_secret:
  #   type: configmap
  #   ref: port-authorizing-config
  #   ref_name: jwt-secret
  #   value: "fallback-value-if-configmap-not-found"
  
  token_expiry: 24h

  # Authentication providers (supports multiple)
  providers:
    # Local authentication (simple username/password)
    - name: local
      type: local
      enabled: true
      config: {}

    # OpenID Connect (via Keycloak or other OIDC provider)
    - name: keycloak
      type: oidc
      enabled: false
      config:
        issuer: "http://localhost:8180/realms/portauth"
        client_id: "port-authorizing"
        client_secret: "your-client-secret-change-in-production"  # Legacy: plain string
        redirect_url: "http://localhost:8080/api/auth/oidc/callback"
        roles_claim: "roles"
        username_claim: "preferred_username"
      # Alternative: Read client_secret from Kubernetes Secret
      # client_secret:
      #   type: secret
      #   ref: oidc-secrets
      #   ref_name: client-secret
      #   value: "fallback-value"

    # LDAP authentication
    - name: corporate-ldap
      type: ldap
      enabled: false
      config:
        url: "localhost:389"
        bind_dn: "cn=admin,dc=portauth,dc=local"
        bind_password: "adminpass"
        user_base_dn: "ou=users,dc=portauth,dc=local"
        user_filter: "(uid=%s)"
        group_base_dn: "ou=groups,dc=portauth,dc=local"
        group_filter: "(member=%s)"
        use_tls: "false"
        skip_tls_verify: "true"

    # SAML2 authentication
    - name: corporate-saml
      type: saml2
      enabled: false
      config:
        idp_metadata_url: "https://idp.example.com/metadata"
        sp_entity_id: "port-authorizing"
        sp_acs_url: "http://localhost:8080/auth/callback/saml2"

  # Legacy local users (backward compatible)
  users:
    - username: admin
      password: admin123  # Use hashed passwords in production
      roles:
        - admin
    - username: developer
      password: dev123
      roles:
        - developer
    - username: qa-user
      password: qa123
      roles:
        - qa

connections:
  # PostgreSQL test database (Docker)
  - name: postgres-test
    type: postgres
    host: localhost
    port: 5432
    duration: 3m
    tags:
      - env:test
      - type:database
      - team:backend
    # Backend credentials can be plain strings (legacy) or from ConfigMap/Secret
    backend_username: "testuser"
    backend_password: "testpass"
    backend_database: "testdb"
    metadata:
      description: "Test PostgreSQL database (Docker)"
      database: "testdb"

  # PostgreSQL staging database (using ConfigMap/Secret for credentials)
  - name: postgres-staging
    type: postgres
    host: staging-db.example.com
    port: 5432
    duration: 15m
    tags:
      - env:staging
      - type:database
      - team:backend
    # Read credentials from Kubernetes Secret
    backend_username:
      type: secret
      ref: postgres-staging-credentials
      ref_name: username
      value: "fallback-username"  # Used if Secret not found
    backend_password:
      type: secret
      ref: postgres-staging-credentials
      ref_name: password
      value: "fallback-password"
    backend_database: "app"
    metadata:
      description: "Staging PostgreSQL database"
      environment: "staging"

  # PostgreSQL production database (using Secrets for credentials)
  - name: postgres-prod
    type: postgres
    host: prod-db.example.com
    port: 5432
    duration: 10m
    tags:
      - env:production
      - type:database
      - team:backend
      - critical:true
    # RECOMMENDED: Use Secrets for production credentials
    backend_username:
      type: secret
      ref: postgres-prod-credentials
      ref_name: username
    backend_password:
      type: secret
      ref: postgres-prod-credentials
      ref_name: password
    backend_database: "app"
    metadata:
      description: "Production PostgreSQL database"
      environment: "production"

  # Nginx test server (Docker)
  - name: nginx-test
    type: http
    host: localhost
    port: 8888
    scheme: http
    duration: 1h
    tags:
      - env:test
      - type:web
    metadata:
      description: "Test Nginx web server (Docker)"

  # Internal API staging
  - name: api-staging
    type: http
    host: api-staging.internal.example.com
    port: 443
    scheme: https
    duration: 2h
    tags:
      - env:staging
      - type:api
      - team:backend
    metadata:
      description: "Internal REST API (Staging)"

  # Internal API production
  - name: api-prod
    type: http
    host: api.internal.example.com
    port: 443
    scheme: https
    duration: 1h
    tags:
      - env:production
      - type:api
      - team:backend
      - critical:true
    metadata:
      description: "Internal REST API (Production)"

  # Redis cache
  - name: redis-cache
    type: tcp
    host: redis.example.com
    port: 6379
    duration: 5m
    tags:
      - env:production
      - type:cache
      - team:platform
    metadata:
      description: "Redis cache server"

# Role-based access policies
# Policies define which roles can access which connections (via tags) and what they can do (whitelist)
policies:
  # Admin policy - full access to everything
  - name: admin-full-access
    roles:
      - admin
    tags:
      - env:test
      - env:staging
      - env:production
    tag_match: any  # Match if connection has ANY of these tags
    whitelist:
      - ".*"  # Allow all queries/requests
    metadata:
      description: "Admins have full access to all environments"

  # Developer policy - full access to test and staging
  - name: developer-test-staging
    roles:
      - developer
    tags:
      - env:test
    tag_match: any
    whitelist:
      - ".*"  # Allow all in test
    metadata:
      description: "Developers have full access to test environment (PostgreSQL and HTTP)"

  - name: developer-staging
    roles:
      - developer
    tags:
      - env:staging
    tag_match: any
    whitelist:
      # PostgreSQL whitelists (for postgres connections)
      - "^SELECT.*"  # Allow SELECT queries
      - "^INSERT INTO logs.*"  # Allow inserting logs
      - "^INSERT INTO events.*"  # Allow inserting events
      - "^UPDATE.*WHERE id.*"  # Allow UPDATE with WHERE clause
      - "^EXPLAIN.*"  # Allow EXPLAIN for query analysis
      # HTTP whitelists (for http/https connections)
      - "^GET .*"  # Allow all GET requests
      - "^POST /api/.*"  # Allow POST to API endpoints
      - "^PUT /api/users/[0-9]+/profile$"  # Allow updating user profiles
      - "^PATCH /api/.*"  # Allow PATCH requests
    metadata:
      description: "Developers have limited access to staging (SELECT, specific INSERTs for DBs; GET, POST, PUT, PATCH for APIs)"

  # Developer policy - read-only access to production
  - name: developer-prod-readonly
    roles:
      - developer
    tags:
      - env:production
    tag_match: any
    whitelist:
      # PostgreSQL whitelists (read-only)
      - "^SELECT.*"  # Allow SELECT queries
      - "^EXPLAIN.*"  # Allow EXPLAIN queries
      # HTTP whitelists (read-only)
      - "^GET .*"  # Allow all GET requests
      - "^HEAD .*"  # Allow HEAD requests
      - "^OPTIONS .*"  # Allow OPTIONS requests (CORS preflight)
    metadata:
      description: "Developers have read-only access to production (SELECT/EXPLAIN for DBs; GET/HEAD/OPTIONS for APIs)"

  # QA policy - full access to test, read-only to staging
  - name: qa-test-full
    roles:
      - qa
    tags:
      - env:test
    tag_match: any
    whitelist:
      - ".*"
    metadata:
      description: "QA has full access to test environment"

  - name: qa-staging-readonly
    roles:
      - qa
    tags:
      - env:staging
    tag_match: any
    whitelist:
      # PostgreSQL whitelists
      - "^SELECT.*"  # Allow SELECT queries
      # HTTP whitelists
      - "^GET .*"  # Allow all GET requests
      - "^HEAD .*"  # Allow HEAD requests
      - "^OPTIONS .*"  # Allow OPTIONS for CORS
    metadata:
      description: "QA has read-only access to staging"

  # Example: team-specific access
  - name: backend-team-databases
    roles:
      - developer
      - admin
    tags:
      - team:backend
      - type:database
    tag_match: all  # Must have ALL these tags
    whitelist:
      - ".*"
    metadata:
      description: "Backend team can access backend databases"

security:
  enable_llm_analysis: false
  llm_provider: "openai"
  llm_api_key: ""
  config_source_cache_ttl: 1m  # How long to cache ConfigMap/Secret values (default: 1m)

logging:
# audit_log_path: "stdout"
  audit_log_path: "audit.log"
  log_level: "info"
  audit_memory_mb: 1  # Max memory for in-memory audit buffer (0 to disable, default 1MB)

# Approval workflow configuration
# Requires human approval for certain commands before execution
approval:
  enabled: false  # Set to true to enable approval workflow

  # Define which requests require approval (regex patterns + tags)
  patterns:
    # Require approval for DELETE operations ONLY on production databases
    - pattern: "^DELETE /.*"
      tags: ["env:production"]  # Only matches connections tagged with env:production
      tag_match: all  # "all" (default) = must have ALL tags, "any" = must have ANY tag
      timeout_seconds: 300  # 5 minutes - how long to wait for human approval

    # Require approval for POST to admin endpoints on ANY environment
    - pattern: "^POST /admin/.*"
      tags: []  # Empty tags = applies to ALL connections
      timeout_seconds: 600  # 10 minutes

    # Require approval for dangerous operations on production OR backend team databases
    - pattern: "^(DROP|TRUNCATE|ALTER) .*"
      tags: ["env:production", "team:backend"]
      tag_match: any  # Matches if connection has ANY of these tags
      timeout_seconds: 900  # 15 minutes

  # Generic webhook for approval notifications
  webhook:
    url: "https://your-approval-service.com/webhook"

  # Slack integration for approvals (with interactive buttons)
  slack:
    # Webhook URL can be plain string (legacy) or from ConfigMap/Secret
    webhook_url: "https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK"
    
    # RECOMMENDED: Read from Kubernetes Secret for production
    # webhook_url:
    #   type: secret
    #   ref: slack-secrets
    #   ref_name: webhook-url
    #   value: "fallback-url-if-secret-not-found"
